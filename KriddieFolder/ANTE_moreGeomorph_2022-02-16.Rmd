---
title: "ANTE_moreGeomorph_2022-02-16"
author: "Kriddie"
date: "2/16/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(plotly)
library(dplyr)
library(tidyr)
library(zoo)
library(plot3D)
library(splines)
library(Ecdat)
library(dplyr)
library(sp)
library(geosphere)
library(DescTools)
library(data.table)
```

##Geomorph Data
make a different data frame with rest of the geomorphdata
```{r read in data}
df_prediction <- read.csv(here::here("ProcessedData/ANTE_synoptic_2022-02-18.csv"))
df_prediction$X <-NULL
```

```{r x and w and d, echo=FALSE}
XWD <- read.csv(here::here("/Geomorphology/Atenas/Antenas_Geomorph_2022-01-28.csv"))

XWD <- XWD[,c("lon","lat","x","d","w","ele","notes")]

#oh what rotten luck. XWD data was collected downstream to upstream and df_prediction is opposite. Let use right this wrong

XWD <- XWD[order(XWD$x),]
XWD$x_diff <- NA

for(i in 1:nrow(XWD)) {       # for-loop over rows
  if (i == 1) {
    XWD$x_diff[i] <- 0
  } else {
    XWD[i,"x_diff"] <-   XWD[i,"x"] - XWD[i-1,"x"]
  }
}

XWD <- XWD[order(-XWD$x),]
XWD$x_new <- NA
for(i in 1:nrow(XWD)) {       # for-loop over rows
  if (i == 1) {
    XWD$x_new[i] <- 0
  } else {
    XWD[i,"x_new"] <-   XWD[i-1,"x_diff"] + XWD[i-1,"x_new"]
  }
}
#great. now get rid of the stuff you don't want
XWD <- XWD[,c("lon","lat","x_new","d","w","ele","notes")]
names(XWD)[names(XWD) == 'x_new'] <- 'x'


```

now we snap XWD data to prediction

```{r snap XDW, echo=FALSE}

XWD_1 <- XWD %>%drop_na(lon)

x <- SpatialPoints(XWD_1[,c(1:2)])
y <- SpatialPoints(df_prediction[,c(1:2)]) 
plot(x, col = "red")
points(y, col = "green")
snap = apply(spDists(x, y), 1, which.min)
points(y[snap,], pch = 3)


snap_df <- y[snap,]
coords_df <- snap_df@coords
pred <- as.data.frame(coords_df)
XWD_1$lon_fit <- pred$lon
XWD_1$lat_fit <- pred$lat
XWD_1 <- full_join(XWD[,c("x","d","w","notes")],XWD_1[,c("lon_fit","lat_fit","x","d","w","notes")],by=c("x","d","w","notes"))

df_prediction_1 <- full_join(df_prediction,XWD_1,by=c("lon_fit","lat_fit"))
#df_prediction_1 <- df_prediction_1%>%drop_na(x) 
df_prediction_1 <- df_prediction_1[,c("lon_fit","lat_fit","dist","x","d","w","notes")]
df_prediction_1 <- unique(df_prediction_1)

```
We've snapped in the waypoints collected while sampling x/width/depth, but there are many points in between don't have corresponding lat/lon/ele. So how to fix these gaps?


Our tools are dist (modeled) and x (measured). Some x are already associated with dist we need to associate all xs with distance. 

If we can identify the xs assiciated with distance, we can then calcualte the difference between each each one. Then calcualte the ratio of x inbetween and total difference

do the same with the difference between the distance assciated with x

then see wich ratio is the closest --> link them up

##do this:
if pt1 and pt2 are known values of x, and pt-btw is known dist but unknown x, then:

(Dist[pt-btw] - Dist[pt1])/(Dist[pt2] - Dist[pt1]) = (unknown - x[pt1])/(x[pt2] - x[pt1])

unknown = (Dist[pt-btw] - Dist[pt1])/(Dist[pt2] - Dist[pt1])*(x[pt2] - x[pt1]) + x[pt1]

##but how do that in a loop?
key to this is being able idntify the next known x in between NAs.

the code below realtes x as measured in the field to distance as calculated with way points. The ancors are waypoints collected every 50 meters in the field 

```{r dist and x, echo=FALSE}
df_prediction_1$notes <- NULL
df_prediction_1$dist_pred <- NULL
df_prediction_1$x_pred <- NULL

df_prediction_1 <- df_prediction_1[order(df_prediction_1$dist),]
pred_df <- na.omit(df_prediction_1[,c("x","dist")])


for(i in 1:nrow(df_prediction_1)) {       # for-loop over rows
  if (is.na(df_prediction_1[i,"x"]) == FALSE) {
    df_prediction_1$x_pred[i] <- df_prediction_1$x[i]

  } else {
    df_prediction_1$dist_pred[i] <- NA
    pt2btw <- df_prediction_1$dist[i]
    dist1 = Closest(pred_df$dist, pt2btw, which = FALSE, na.rm = FALSE)
    if (dist1 < pt2btw ) {#x[! x %in% 2:10]
    dist2 = Closest(pred_df$dist[pred_df$dist > dist1], pt2btw, which = FALSE, na.rm = FALSE)}
    else{
      dist2 = Closest(pred_df$dist[pred_df$dist < dist1], pt2btw, which = FALSE, na.rm = FALSE)
    }
    pt1dist = min(dist1,dist2)
    pt2dist = max(dist1,dist2)
    
    pt1x = pred_df$x[which(pred_df$dist == pt1dist)]
    pt2x = pred_df$x[which(pred_df$dist == pt2dist)]
    df_prediction_1$x_pred[i] <- pt2x - (pt2dist-df_prediction_1$dist[i])/(pt2dist-pt1dist)*(pt2x-pt1x)
  }
}
```

Now we have a data frame with x predicted and associated with distance. Now we associate the closest actual x measurments, depth and width with the predicted x  



```{r width loop, echo=FALSE}
df_prediction_2 <- df_prediction_1[,c("lon_fit","lat_fit","dist","x_pred")]%>%drop_na(dist)

XWD_fit <- XWD_1[,c("x","w","d","notes")]
colnames(XWD_fit) <- c("x_pred","w","d","notes")

setDT(df_prediction_2)
setDT(XWD_fit)

df_prediction_3 <- df_prediction_2[XWD_fit, roll = "nearest", on = "x_pred"]

for(i in 1:nrow(df_prediction_1)) {       # for-loop over rows
 }
```

AHHHH i can't believe that wooooorrrrkkkkeedddddddddddd!!!!!!

#SLOPE

```{r loopy, echo=FALSE}
ANTE <- read.csv(here::here("/ProcessedData/ANTE_synoptic_2022-02-16.csv"))
ANTE$X <- NULL

##choose the length of distance to use for calculating slope
#also consider how much before or after the sample point
#remeber - gps accuracy is 3m at best

save = ANTE[1,]
save$slope <- NA
loop <- ANTE%>%drop_na(ele_fit)
for(i in 1:nrow(loop)) {       # for-loop over rows
  x = loop$dist[i] - 10
  loop$ele_minus[i] <- loop[which.min(abs(loop$dist-x)),]$ele_fit
  loop$dist_minus[i] <- loop[which.min(abs(loop$dist-x)),]$dist
  
  y = loop$dist[i] + 3
  loop$ele_plus[i] <- loop[which.min(abs(loop$dist-y)),]$ele_fit
  loop$dist_plus[i] <- loop[which.min(abs(loop$dist-y)),]$dist
  
  loop$slope <- -1*(loop$ele_minus-loop$ele_plus)/(loop$dist_minus-loop$dist_plus)
  
}
loop$dist_minus <- NULL
loop$dist_plus <- NULL
loop$ele_minus <- NULL
loop$ele_plus <- NULL

ANTE <- rbind(save, loop)

```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
